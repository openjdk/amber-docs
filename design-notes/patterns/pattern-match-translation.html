<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>pattern-match-translation</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
      <style type="text/css">
        A IMG { border-width: 0px; }
  
        BODY {
            background: white;
            margin: 2em;
          font-size: medium;
          max-width: 60em;
          margin-bottom: 100%;
          font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
        }
  
        code, pre, tt {
  	font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  	font-size: medium
        }
  
        code {
            display: inline-block;
            padding: .1em .2em;
          font-size: 90%;
          border-radius: 6px;
  	background-color: #f6f8fa;
          box-sizing: border-box;
        }
  
        h1 {
  	  font-size: 32px;
        }
  
        h1,
        h2 {
  	  font-weight: 600;
            border-bottom: 1px solid #e8e8e8;
        }
        
        h2 {
  	  font-size: 24px
        }
        
        h3 {
  	  font-size: 20px
        }
        
        h3,
        h4 {
  	  font-weight: 600
        }
        
        h4 {
  	  font-size: 20px
        }
  
        P { margin: 1ex 0em; }
        P.subsection { margin-top: 2ex; }
        P.subsection:first-child { margin-top: 1ex; }
        P SPAN.title { font-weight: bold; padding-right: 1em; }
  
        PRE {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #f6f8fa;
        }
  
        .sidebar {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #e8e8e8;
        }
  
        .control-character {
            color: #bbb;
            font-style: italic;
        }
  
        /* added for ```{.jvm} support */
        PRE.jvm { font-style: italic; }
  
        BLOCKQUOTE { margin: 1.5ex 2em; font-style: italic; border-left: 0.2em solid gray; padding-left: 1em; }
        LI BLOCKQUOTE { margin-left: 0em; }
        LI { margin: 0ex 0em; }
  
        TABLE, TH, TD { border: 1px solid #e8e8e8;
                        padding: 6px 12px; }
        TR:nth-child(2n) {
            background-color: #f6f8fa;
        }
        TH { font-weight: 600 }
        TABLE { border-collapse: collapse; }
        TD { vertical-align: top; }
  
        UL LI { list-style-type: square; }
  
        DIV.summary { margin: 2ex 2em; }
  
        DIV.head { margin-bottom: 2em; }
        DIV.doctitle { font-size: x-large; font-weight: bold; }
        DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;
                    margin-bottom: 1.5ex; }
        DIV.authors { margin-top: 1ex; font-size: large; }
        DIV.author A { font-style: italic; }
        DIV.version { font-size: medium; margin-top: 1ex; }
        DIV.copyright, DIV.comments { font-size: small; }
        DIV.version SPAN.modified { color: green; font-weight: bold; }
        DIV.head DIV.notes { margin-top: 1ex; }
        DIV.qa { margin-top: 2ex; }
        DIV.footer { padding-top: 4em; text-align: center; font-size: 7pt; }
        
        /* added because pandoc syntax highlighting always uses scroll bars */
        DIV.sourceCode {
            overflow: visible;
        }
  
        HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }
     </style>
</head>
<body>
<h1 id="pattern-matching-for-java-runtime-and-translation">Pattern Matching for Java – Runtime and Translation</h1>
<h4 id="brian-goetz-and-john-rose-june-2017">Brian Goetz and John Rose, June 2017</h4>
<p>This document explores compiler translation strategies and runtime support for supporting <a href="pattern-matching-for-java.html"><em>pattern matching</em></a> in the Java Language. This is an exploratory document only and does not constitute a plan for any specific feature in any specific version of the Java Language. This document also may reference other features under exploration; this is purely for illustrative purposes, and does not constitute any sort of plan or committment to deliver any of these features.</p>
<h2 id="background">Background</h2>
<p>We’ve proposed several kinds of <a href="pattern-matching-for-java.html">patterns</a>, such as deconstructor patterns, constant patterns, and type test patterns, and several linguistic contexts in which pattern matching might be supported (<code>match</code> predicate, <code>switch</code> statement). An obvious question is: what bytecode should the compiler generate for a pattern match, or for the implementation of a pattern? (There is also the question of how one might declare a pattern in source code; this is a topic for a separate document.)</p>
<h4 id="what-is-a-pattern">What is a pattern?</h4>
<p>A <em>pattern</em> is a combination of a <em>predicate</em> that can be applied to a target, and a set of <em>binding variables</em> that are produced if that predicate applies. We can model a pattern as a typed tuple <em>&lt;T,B*&gt;(z, b*)</em>, where <em>T</em> is the <em>target type</em> of the pattern, <em>B*</em> are the types of the binding variables, <em>z</em> is a function <em>T-&gt;bool</em> representing the predicate, and <em>b*</em> is a vector of partial functions <em>T-&gt;Bi</em> that produce the binding variables.</p>
<p>Some patterns are <em>total</em>; they match any target, and so their predicate always returns <code>true</code>. If a pattern is known to be total at compile time, the compiler can use this knowledge to aid in exhaustiveness analysis.</p>
<p>We’ve chosen to model patterns as nominal executable class members (like methods or constructors). A pattern is the dual of a method or constructor; where methods and constructors take <em>N</em> arguments and produce one result, a pattern takes one argument and produces <em>N</em> results.</p>
<h4 id="encoding-patterns-as-methods">Encoding patterns as methods</h4>
<p>It is easy – though neither performant nor consequence-free – to model patterns as ordinary methods. Scala models patterns using static <code>unapply</code> methods, which take a single argument and produces either <code>Boolean</code> or an <code>Option</code> wrapper for one or more values to communicate both the success/failure and the resulting binding variables in a single invocation. From a user and compiler perspective, this is fine; the pattern</p>
<pre><code>def unapply(p : Point) : Option[(int, int)] = Some(p.x, p.y)</code></pre>
<p>is clear enough (successfully deconstructing a <code>Point</code> results in an <code>(int,int)</code> pair), and the compiler can readily translate pattern matches into <code>unapply</code> calls. However, from a cost perspective, this is pretty bad; the <code>Option</code> is a heap-based box, the <code>Tuple</code> is a heap-based box, and, in the absence of specialization, each <code>int</code> is boxed into an <code>Integer</code>, for a total of four heap nodes per match.</p>
<p>This heap-based approach is the obvious one given a VM that lacks the mechanisms that would make stack-based approaches possible, such as multiple return (leaving multiple values on the stack), out parameters (an alternate encoding of multiple return), uplevel references to locals (providing down-stack frames the ability to access up-stack locals), or value types (unboxed aggregates.)</p>
<p>However, with method handles, <code>invokedynamic</code> (indy), and soon, <code>constantdynamic</code> (condy), we can encode a pattern so that most pattern match operations can proceed without boxing, in a manner highly optimizable by the JIT, and, as a bonus, in a way that can be used across JVM languages.</p>
<h4 id="further-performance-considerations">Further performance considerations</h4>
<p>The most common case of a pattern is that there is no significant shared computation between testing to see if the pattern applies to the target and extracting the various components. For example, if we are destructuring a <code>Point</code>, our test is an <code>instanceof</code> test, and component extraction is field access.</p>
<p>The uncommon case is that there is either significant shared computation, or there are atomicity requirements that say that the components should be extracted in a single atomic operation. In both cases, it is desirable (in the latter case, necessary) to have an intermediate carrier to hold the match state. (In the common case, we can think of the target as acting as its own carrier.)</p>
<p>We want to identify an encoding for matchers such that the common cases are fast and allocation free, but that it is possible to use an intermediate result carrier where that is required by semantics (i.e., <code>synchronized</code> patterns) or desired for efficiency reasons. Further, it should be a binary compatible change to switch from one mode to the other – client code shouldn’t have to distinguish the two at runtime. And, for matchers that use intermediate result carriers, it should be a binary compatible change to migrate to using a value type as a carrier in the future.</p>
<h2 id="basic-strategy">Basic strategy</h2>
<p>We’ll start with the runtime representation and work our way up to classfile representation (and later, source file representation). Our runtime strategy represents a pattern as a constant bundle of method handles. Let’s cover the simple (common) case and then we’ll add in machinery for the general case.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">interface</span> __Pattern {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="dt">int</span> <span class="fu">numComponents</span>();</a>
<a class="sourceLine" id="cb2-3" title="3">    MethodHandle <span class="fu">predicate</span>();      <span class="co">// T -&gt; bool</span></a>
<a class="sourceLine" id="cb2-4" title="4">    MethodHandle <span class="fu">component</span>(<span class="dt">int</span> i); <span class="co">// T -&gt; Bi</span></a>
<a class="sourceLine" id="cb2-5" title="5">}</a></code></pre></div>
<p>To emit pattern-matching code, a compiler has to acquire a reference to the pattern object (likely via indy/condy), ask the pattern for its predicate method handle, invoke the predicate handle on the target, and, if the predicate succeeds, ask the pattern for the component method handles and invoke them on the target. (We can further use indy/condy to cache the individual method handles, moving the “ask the pattern for its handles” code to link time.) If the pattern is statically known to be total, then invoking the <code>predicate</code> can be omitted.</p>
<p>Illustrating deconstructing a <code>Point</code> into its <code>x</code> and <code>y</code> components using Java code (though in reality, this would only be called by compiler-generated code, or via reflection):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" title="1">__Pattern p = ...;                       <span class="co">// constant</span></a>
<a class="sourceLine" id="cb3-2" title="2">MethodHandle predicate = p.<span class="fu">predicate</span>();  <span class="co">// constant</span></a>
<a class="sourceLine" id="cb3-3" title="3">MethodHandle pointX = p.<span class="fu">component</span>(<span class="dv">0</span>);    <span class="co">// constant</span></a>
<a class="sourceLine" id="cb3-4" title="4">MethodHandle pointY = p.<span class="fu">component</span>(<span class="dv">1</span>);    <span class="co">// constant</span></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">if</span> ((<span class="dt">boolean</span>) predicate.<span class="fu">invoke</span>(target)) {</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="dt">int</span> x = (<span class="dt">int</span>) pointX.<span class="fu">invoke</span>(target);</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="dt">int</span> y = (<span class="dt">int</span>) pointY.<span class="fu">invoke</span>(target);</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="kw">... </span>use x and y ...</a>
<a class="sourceLine" id="cb3-9" title="9">}</a></code></pre></div>
<h4 id="intermediate-carriers">Intermediate carriers</h4>
<p>As mentioned, there is a minority of cases where an intermediate carrier is needed to hold the results of preprocessing the target (which might just precompute the components and store them in a holder aggregate, or might just compute precursors for computing the bindings). We can model a pattern with such a carrier as a tuple <em>&lt;T,C,B*&gt;(p,z,b*)</em>, where <em>C</em> is the carrier type, <em>p</em> is a preprocessing function from <code>T-&gt;C</code>, and the predicate <em>z</em> and binding functions <em>b*</em> are extended to take both the target and the carrier as arguments (and in practice, will likely ignore one or the other of them.) So the predicate <em>p</em> is a function <code>(T,C)-&gt;bool</code>, and similar for the binding functions.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">interface</span> __Pattern {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="dt">int</span> <span class="fu">numComponents</span>();</a>
<a class="sourceLine" id="cb4-3" title="3">    MethodHandle <span class="fu">preprocess</span>();     <span class="co">// T -&gt; C</span></a>
<a class="sourceLine" id="cb4-4" title="4">    MethodHandle <span class="fu">predicate</span>();      <span class="co">// (T,C) -&gt; bool</span></a>
<a class="sourceLine" id="cb4-5" title="5">    MethodHandle <span class="fu">component</span>(<span class="dt">int</span> i); <span class="co">// (T,C) -&gt; Bi</span></a>
<a class="sourceLine" id="cb4-6" title="6">}</a></code></pre></div>
<p>Patterns that cannot tolerate concurrent interference can extract the components into a carrier with the appropriate lock held, as can patterns requiring complex imperative logic – without the client having to treat this case separately. This protocol is designed to prevent the uncommon carrier-ful case(s) from polluting the common carrier-free case with heap allocation (and when needed, we can eventually use value types rather than reference types for carriers.)</p>
<p>The choice of carrier type is ideally an implementation choice by the class declaring the pattern, but must be subject to some migration compatibility constraints, since existing client code will embed the carrier type in call sites.</p>
<h4 id="combinators">Combinators</h4>
<p>This strategy also allows us to move much of the work of implementing pattern matching into the runtime (without sacrificing efficiency), rather than burdening the compiler. Because patterns are constant bundles of functions, we can compose them in interesting ways. For example, suppose we have patterns <em>P&lt;T,C1,A*&gt;(pp,pz,pb*)</em> and <em>Q&lt;T,C2,B*&gt;(qp,qz,qb*)</em>. We can create a combinator for the pattern <em>R</em> representing <em>P &amp;&amp; Q</em> as follows:</p>
<ul>
<li>The target types of <code>P</code> and <code>Q</code> must be the same, and the target type of <code>R</code> is the same as <code>P</code> and <code>Q</code>;</li>
<li>The carrier type of <code>R</code> is nominally the tuple <code>(C1,C2)</code>, though in practice this can be optimized away if either <code>P</code> or <code>Q</code> (or ideally, both) is carrier-free;</li>
<li>The <code>preprocess</code> of <code>R</code> applies the <code>preprocess</code> of both <code>P</code> and <code>Q</code>, and constructs a carrier that holds both results;</li>
<li>The <code>predicate</code> of <code>R</code> the logical <code>AND</code> of the predicates of <code>P</code> and <code>Q</code>;</li>
<li>The components of <code>R</code> is the concatenation of the components of <code>P</code> and <code>Q</code>.</li>
</ul>
<p>Such combinators act only on the (constant) pattern objects, and are themselves constant pattern objects, so are suitable to construct at link time with indy/condy. As a result, compilers can destructure complex patterns (AND, OR, nested, guarded) into the same pattern protocol, allowing uniform code generation, and move the complexity of complex pattern generation to link time via indy/condy.</p>
<h2 id="classfile-encoding">Classfile encoding</h2>
<p>Logically, patterns are members of classes, like methods and constructors, though we cannot use the exact encoding of these artifacts for reasons outlined earlier.</p>
<p>Just as executable members include constructors, static methods, and instance methods, each of these cases is potentially sensible for patterns as well. We’ve already enumerated several types of useful patterns; match-everything patterns, type-test patterns, deconstruction patterns, etc. Deconstruction patterns (e.g., <code>Point(var x, var y)</code>) are analogous to constructors – in fact, for well-behaved objects, they are the dual of constructors. And static patterns are the dual of static factories.</p>
<p>Like methods, patterns have names, and it is reasonable to want to overload multiple patterns with the same name but different signatures. For example, suppose we have overloaded constructors:</p>
<pre><code>File(String s) { ... }
File(Path p) { ... }
File(URI u) { ... }</code></pre>
<p>We have these constructors for client convenience – whatever the client has, we can make a <code>File</code> out of that. So similarly, we want deconstructing a <code>File</code> to be equally convenient, and expose overloaded patterns:</p>
<pre><code>case File(String name): ...
-- or --
case File(Path p): ...
-- or --
case File(URI u): ...</code></pre>
<h4 id="method-naming">Method naming</h4>
<p>Even if we could easily represent patterns as methods in a class file, we can easily fall afoul of overloading constraints. If we took the Scala approach and mapped these all to methods returning <code>Tuple</code> or <code>Option[Tuple]</code>, erasure would prevent us from overloading in this way.</p>
<p>But, since our runtime representation is a constant bundle of method handles, we have a different option – generate methods not to do the matching and extraction, but instead generate methods to return a <code>__Pattern</code> (which can be invoked at link time via indy/condy). And because matchers are not called directly, but instead through pattern matching (or reflection), it doesn’t really matter what we call these methods, so long as we preserve some reasonable compatibility requirements.</p>
<p>It’s worth noting that we can use the <code>MethodType</code> type to describe a pattern – in reverse. Where a method has multiple inputs and one output, a pattern has one input and multiple outputs. So we can use <code>MethodType</code> to construct a descriptor for a pattern, just inverting the input/output sense. So the <code>String</code>-consuming <code>File</code> constructor and the <code>String</code>-producing <code>File</code> pattern could both be described the method type <code>(LString;)LFile;</code>. (This duality is not accidental; the two operations are inverses of each other.) So let’s call <code>D</code> the descriptor for a pattern, and <code>N</code> the name for the pattern (deconstruction patterns are named for the class, just like constructors.)</p>
<p>If we pick an encoding scheme that can stably encode a descriptor and is resistent to collisions between overload-equivalent strings (such as the <a href="https://blogs.oracle.com/jrose/entry/symbolic_freedom_in_the_vm">symbolic freedom encoding</a>), we can construct an identifier <code>DD=Enc(N,D)</code> and generate static factory methods:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="dt">static</span> __Pattern <span class="fu">DD</span>() { <span class="kw">... </span>}</a></code></pre></div>
<p>Just as with methods, we need to encode some additional information, such as generic type signature, which we can do with an attribute, such as:</p>
<pre><code>Deconstructor_attribute {
    u2 name_index;
    u4 length;
    u1 is_total;
    u2 carrier_type;        // UTF8 type descriptor
    u2 generic_signature;   // S (UTF8 signature)
}</code></pre>
<h4 id="additional-optimizations">Additional optimizations</h4>
<p>It may be desirable for a <code>__Pattern</code> to convey, at run time, that it is carrier-free; this enables combinators to optimize away boxes for tuples of carriers. For patterns that use value type carriers, it may also be useful for the <code>__Pattern</code> to be willing to dispense a sentinel value for the chosen carrier, which can also be used to optimize combinators.</p>
<p>This design is extremely <code>condy</code>- and JIT-friendly; the compiler can generate descriptions of constants to describe exactly the patterns, or sub-parts of patterns, that are needed, and rely on constant pool caching to provide fast lazy initialization (with all initialization costs paid at link time.) The JIT will recognize that all method handles used for pattern matching are grounded in chains of constants, and so will routinely inline away all the intermediate data-shuffling code and carrier management code.</p>
<h4 id="data-classes">Data classes</h4>
<p>Even in the absence of a language syntax for declaring member patterns, the <em>data classes</em> feature currently under consideration lends itself cleanly to automatically exposing a pattern which matches the class signature (and the constructor signature).</p>
<h4 id="reflection">Reflection</h4>
<p>As patterns are class members, we’ll need reflective support for discovering and invoking patterns. This is a straightforward extension of existing reflective support for <code>Constructor</code> and <code>Method</code> members, which are wrappers around the <code>__Pattern</code> runtime abstraction.</p>
<h2 id="migration-compatibility">Migration compatibility</h2>
<p>Because compile-time information is used to condition code generation, we need to be clear about what can change, and can’t, in a binary-compatible way.</p>
<p>Compilers can use pattern total-ness to make exhaustiveness decisions, which is extremely useful. To be able to rely on this, total-ness should be an intrinsic property of the pattern that does not change across maintenance, and changing a total pattern to partial should not be a binary- or source-compatible change.</p>
<p>However, we envision patterns changing their carrier types, either changing from a box object to a value type when practical, or going from a carrier-free to a carrier-ful implementation through ordinary code evolution. Therefore, existing call sites that embed the carrier type must continue to link, which means that if we are changing a carrier from <code>C</code> to <code>D</code>, then <code>C</code> and <code>D</code> should be adaptable to each other via <code>MethodHandles.asType()</code>. Migrating carriers from a reference type <code>LFoo</code> to a value type <code>QFoo</code> would be supported by <code>asType()</code>. (This suggests that carrier-free implementations should use <code>LObject</code>, allowing future implementations to migrate to a subtype of <code>LObject</code>, or to a value type.)</p>
<h2 id="strawman-api">Strawman API</h2>
<p>We’ve built a prototype of this approach. It has factories for constant patterns, type test patterns, any patterns, and deconstruction patterns, and combinators for dropping bindings, adapting the target to a supertype of the target, ANDing patterns together, and nesting patterns.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> __Pattern&lt;T&gt; {</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-3" title="3">     <span class="co">*</span> A method handle used to preprocess a target into an intermediate carrier<span class="co">.</span></a>
<a class="sourceLine" id="cb9-4" title="4">     <span class="co">*</span> The method handle accepts a match target and returns the intermediate</a>
<a class="sourceLine" id="cb9-5" title="5">     <span class="co">*</span> carrier<span class="co">.</span></a>
<a class="sourceLine" id="cb9-6" title="6">     <span class="co">*</span></a>
<a class="sourceLine" id="cb9-7" title="7">     <span class="co">*</span> If the carrierFree<span class="co">()</span> method returns true<span class="co">,</span> then this method need not be</a>
<a class="sourceLine" id="cb9-8" title="8">     <span class="co">*</span> called<span class="co">,</span> and null can be used for the carrier in other method handle</a>
<a class="sourceLine" id="cb9-9" title="9">     <span class="co">*</span> invocations<span class="co">.</span></a>
<a class="sourceLine" id="cb9-10" title="10">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-11" title="11">    MethodHandle <span class="fu">preprocess</span>();</a>
<a class="sourceLine" id="cb9-12" title="12"></a>
<a class="sourceLine" id="cb9-13" title="13">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-14" title="14">     <span class="co">*</span> A method handle used to determine if the match succeeds<span class="co">. </span> It accepts</a>
<a class="sourceLine" id="cb9-15" title="15">     <span class="co">*</span> the match target and the intermediate carrier returned by preprocess<span class="co">(),</span></a>
<a class="sourceLine" id="cb9-16" title="16">     <span class="co">*</span> and returns a boolean indicating whether the match was successful<span class="co">.</span></a>
<a class="sourceLine" id="cb9-17" title="17">     <span class="co">*</span></a>
<a class="sourceLine" id="cb9-18" title="18">     <span class="co">*</span> If the pattern is declared to always match<span class="co">,</span> then this method need not be</a>
<a class="sourceLine" id="cb9-19" title="19">     <span class="co">*</span> called<span class="co">.</span></a>
<a class="sourceLine" id="cb9-20" title="20">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-21" title="21">    MethodHandle <span class="fu">predicate</span>();</a>
<a class="sourceLine" id="cb9-22" title="22"></a>
<a class="sourceLine" id="cb9-23" title="23">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-24" title="24">     <span class="co">*</span> A method handle to return the i<span class="co">&#39;</span>th component of a successful match<span class="co">. </span> It</a>
<a class="sourceLine" id="cb9-25" title="25">     <span class="co">*</span> accepts the match target and the intermediate carrier returned by</a>
<a class="sourceLine" id="cb9-26" title="26">     <span class="co">*</span> preprocess<span class="co">(),</span> and returns the component<span class="co">.</span></a>
<a class="sourceLine" id="cb9-27" title="27">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-28" title="28">    MethodHandle <span class="fu">component</span>(<span class="dt">int</span> i);</a>
<a class="sourceLine" id="cb9-29" title="29"></a>
<a class="sourceLine" id="cb9-30" title="30">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-31" title="31">     <span class="co">*</span> Indicates that this pattern does not make use of an intermediate carrier<span class="co">,</span></a>
<a class="sourceLine" id="cb9-32" title="32">     <span class="co">*</span> and that the tryExact<span class="co">()</span> method handle is a no<span class="co">-</span>op<span class="co">.</span></a>
<a class="sourceLine" id="cb9-33" title="33">     <span class="co">*</span> Combinators exploit carrier freedom to reduce unnecessary allocation<span class="co">.</span></a>
<a class="sourceLine" id="cb9-34" title="34">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-35" title="35">    <span class="dt">boolean</span> <span class="fu">isCarrierFree</span>();</a>
<a class="sourceLine" id="cb9-36" title="36"></a>
<a class="sourceLine" id="cb9-37" title="37">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-38" title="38">     <span class="co">*</span> Returns the pattern descriptor<span class="co">,</span> which is a MethodType whose return type</a>
<a class="sourceLine" id="cb9-39" title="39">     <span class="co">*</span> is the match target<span class="co">,</span> and whose parameter types are the components of the</a>
<a class="sourceLine" id="cb9-40" title="40">     <span class="co">*</span> match<span class="co">.</span></a>
<a class="sourceLine" id="cb9-41" title="41">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-42" title="42">    MethodType <span class="fu">descriptor</span>();</a>
<a class="sourceLine" id="cb9-43" title="43"></a>
<a class="sourceLine" id="cb9-44" title="44">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-45" title="45">     <span class="co">*</span> Returns the match target type</a>
<a class="sourceLine" id="cb9-46" title="46">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-47" title="47">    <span class="kw">default</span> <span class="bu">Class</span>&lt;?&gt; <span class="fu">targetType</span>() {</a>
<a class="sourceLine" id="cb9-48" title="48">        <span class="kw">return</span> <span class="fu">descriptor</span>().<span class="fu">returnType</span>();</a>
<a class="sourceLine" id="cb9-49" title="49">    }</a>
<a class="sourceLine" id="cb9-50" title="50"></a>
<a class="sourceLine" id="cb9-51" title="51">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-52" title="52">     <span class="co">*</span> Return the intermediate carrier type</a>
<a class="sourceLine" id="cb9-53" title="53">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-54" title="54">    <span class="kw">default</span> <span class="bu">Class</span>&lt;?&gt; <span class="fu">carrierType</span>() {</a>
<a class="sourceLine" id="cb9-55" title="55">        <span class="kw">return</span> <span class="fu">preprocess</span>().<span class="fu">type</span>().<span class="fu">returnType</span>();</a>
<a class="sourceLine" id="cb9-56" title="56">    }</a>
<a class="sourceLine" id="cb9-57" title="57"></a>
<a class="sourceLine" id="cb9-58" title="58">    <span class="co">// -- Combinators --</span></a>
<a class="sourceLine" id="cb9-59" title="59"></a>
<a class="sourceLine" id="cb9-60" title="60">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-61" title="61">     <span class="co">*</span> Return a __Pattern that is identical to this one<span class="co">,</span> but with fewer</a>
<a class="sourceLine" id="cb9-62" title="62">     <span class="co">*</span> binding components</a>
<a class="sourceLine" id="cb9-63" title="63">     <span class="co">* </span><span class="an">@param positions </span>indices of the binding components to drop</a>
<a class="sourceLine" id="cb9-64" title="64">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-65" title="65">    <span class="kw">default</span> __Pattern&lt;T&gt; <span class="fu">dropBindings</span>(<span class="dt">int</span><span class="kw">... </span>positions) {</a>
<a class="sourceLine" id="cb9-66" title="66">        <span class="kw">return</span> __Patterns.<span class="fu">dropBindings</span>(<span class="kw">this</span>, positions);</a>
<a class="sourceLine" id="cb9-67" title="67">    }</a>
<a class="sourceLine" id="cb9-68" title="68"></a>
<a class="sourceLine" id="cb9-69" title="69">    <span class="co">// -- Factories --</span></a>
<a class="sourceLine" id="cb9-70" title="70"></a>
<a class="sourceLine" id="cb9-71" title="71">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-72" title="72">     <span class="co">*</span> Return a pattern handle that matches a constant</a>
<a class="sourceLine" id="cb9-73" title="73">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-74" title="74">    <span class="dt">static</span> &lt;T&gt; __Pattern&lt;T&gt; <span class="fu">ofConstant</span>(<span class="bu">Class</span>&lt;T&gt; targetType, T constant) {</a>
<a class="sourceLine" id="cb9-75" title="75">        <span class="kw">return</span> __Patterns.<span class="fu">ofConstant</span>(targetType, constant);</a>
<a class="sourceLine" id="cb9-76" title="76">    }</a>
<a class="sourceLine" id="cb9-77" title="77"></a>
<a class="sourceLine" id="cb9-78" title="78">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-79" title="79">     <span class="co">*</span> Return a pattern handle that matches null</a>
<a class="sourceLine" id="cb9-80" title="80">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-81" title="81">    <span class="dt">static</span> &lt;T&gt; __Pattern&lt;<span class="bu">Object</span>&gt; <span class="fu">ofNull</span>() {</a>
<a class="sourceLine" id="cb9-82" title="82">        <span class="kw">return</span> __Patterns.<span class="fu">ofNull</span>();</a>
<a class="sourceLine" id="cb9-83" title="83">    }</a>
<a class="sourceLine" id="cb9-84" title="84"></a>
<a class="sourceLine" id="cb9-85" title="85">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-86" title="86">     <span class="co">*</span> Return a pattern handle that matches a non<span class="co">-</span>null reference</a>
<a class="sourceLine" id="cb9-87" title="87">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-88" title="88">    <span class="dt">static</span>&lt;T&gt; __Pattern&lt;T&gt; <span class="fu">ofNonNull</span>(<span class="bu">Class</span>&lt;T&gt; targetType) {</a>
<a class="sourceLine" id="cb9-89" title="89">        <span class="kw">return</span> __Patterns.<span class="fu">ofNonNull</span>(targetType);</a>
<a class="sourceLine" id="cb9-90" title="90">    }</a>
<a class="sourceLine" id="cb9-91" title="91"></a>
<a class="sourceLine" id="cb9-92" title="92">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-93" title="93">     <span class="co">*</span> Return a pattern handle that matches targets of the type testType<span class="co">,</span> and</a>
<a class="sourceLine" id="cb9-94" title="94">     <span class="co">*</span> produces its target as a binding component<span class="co">. </span> If</a>
<a class="sourceLine" id="cb9-95" title="95">     <span class="co">*</span> testType <span class="co">==</span> targetType<span class="co">,</span> this pattern will always succeed<span class="co">.</span></a>
<a class="sourceLine" id="cb9-96" title="96">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-97" title="97">    <span class="dt">static</span> &lt;T, U <span class="kw">extends</span> T&gt; __Pattern&lt;T&gt; <span class="fu">ofType</span>(<span class="bu">Class</span>&lt;T&gt; targetType, <span class="bu">Class</span>&lt;U&gt; testType) {</a>
<a class="sourceLine" id="cb9-98" title="98">        <span class="kw">return</span> __Patterns.<span class="fu">ofType</span>(targetType, testType);</a>
<a class="sourceLine" id="cb9-99" title="99">    }</a>
<a class="sourceLine" id="cb9-100" title="100"></a>
<a class="sourceLine" id="cb9-101" title="101">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-102" title="102">     <span class="co">*</span> Return a pattern handle for a given target type that always succeeds<span class="co">,</span> and</a>
<a class="sourceLine" id="cb9-103" title="103">     <span class="co">*</span> produces its target as a binding component<span class="co">.</span></a>
<a class="sourceLine" id="cb9-104" title="104">     <span class="co">*</span></a>
<a class="sourceLine" id="cb9-105" title="105">     <span class="co">*</span> To accept a broader range of target types<span class="co">,</span> use <span class="an">{@link </span>__Pattern<span class="an">::</span>ofType<span class="an">(</span>Class<span class="an">,</span>Class<span class="an">)}</span></a>
<a class="sourceLine" id="cb9-106" title="106">     <span class="co">*</span> or <span class="an">{@link </span>__Pattern<span class="an">::</span>adaptTarget<span class="an">}</span></a>
<a class="sourceLine" id="cb9-107" title="107">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-108" title="108">    <span class="dt">static</span> &lt;T&gt; __Pattern&lt;T&gt; <span class="fu">ofType</span>(<span class="bu">Class</span>&lt;T&gt; targetType) {</a>
<a class="sourceLine" id="cb9-109" title="109">        <span class="kw">return</span> __Patterns.<span class="fu">ofType</span>(targetType, targetType);</a>
<a class="sourceLine" id="cb9-110" title="110">    }</a>
<a class="sourceLine" id="cb9-111" title="111"></a>
<a class="sourceLine" id="cb9-112" title="112">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-113" title="113">     <span class="co">*</span> Return a pattern handle that always succeeds</a>
<a class="sourceLine" id="cb9-114" title="114">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-115" title="115">    <span class="dt">static</span> &lt;T&gt; __Pattern&lt;T&gt; <span class="fu">ofAny</span>(<span class="bu">Class</span>&lt;T&gt; targetType) {</a>
<a class="sourceLine" id="cb9-116" title="116">        <span class="kw">return</span> __Patterns.<span class="fu">ofAny</span>(targetType);</a>
<a class="sourceLine" id="cb9-117" title="117">    }</a>
<a class="sourceLine" id="cb9-118" title="118"></a>
<a class="sourceLine" id="cb9-119" title="119">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-120" title="120">     <span class="co">*</span> Return a pattern handle that tests its target against testType<span class="co">,</span> and<span class="co">,</span> if</a>
<a class="sourceLine" id="cb9-121" title="121">     <span class="co">*</span> successful<span class="co">,</span> extracts components from it according to the <span class="an">{@code components}</span></a>
<a class="sourceLine" id="cb9-122" title="122">     <span class="co">*</span> array of method handles<span class="co">,</span> which each accept a single argument of <span class="an">{@code typeTest}</span></a>
<a class="sourceLine" id="cb9-123" title="123">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-124" title="124">    <span class="dt">static</span> &lt;T, U <span class="kw">extends</span> T&gt; __Pattern&lt;T&gt; <span class="fu">ofComponents</span>(<span class="bu">Class</span>&lt;T&gt; targetType,</a>
<a class="sourceLine" id="cb9-125" title="125">                                                          <span class="bu">Class</span>&lt;U&gt; testType,</a>
<a class="sourceLine" id="cb9-126" title="126">                                                          MethodHandle<span class="kw">... </span>components) {</a>
<a class="sourceLine" id="cb9-127" title="127">        <span class="kw">return</span> __Patterns.<span class="fu">ofComponents</span>(targetType, testType, components);</a>
<a class="sourceLine" id="cb9-128" title="128">    }</a>
<a class="sourceLine" id="cb9-129" title="129"></a>
<a class="sourceLine" id="cb9-130" title="130">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-131" title="131">     <span class="co">*</span> Adapt a pattern handle to a broader target type<span class="co">.</span></a>
<a class="sourceLine" id="cb9-132" title="132">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-133" title="133">    <span class="dt">static</span>&lt;T, U <span class="kw">extends</span> T&gt; __Pattern&lt;T&gt; <span class="fu">adaptTarget</span>(<span class="bu">Class</span>&lt;T&gt; targetType,</a>
<a class="sourceLine" id="cb9-134" title="134">                                                        __Pattern&lt;U&gt; pattern) {</a>
<a class="sourceLine" id="cb9-135" title="135">        <span class="kw">return</span> __Patterns.<span class="fu">adaptTarget</span>(pattern, targetType);</a>
<a class="sourceLine" id="cb9-136" title="136">    }</a>
<a class="sourceLine" id="cb9-137" title="137"></a>
<a class="sourceLine" id="cb9-138" title="138">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-139" title="139">     <span class="co">*</span> Return a pattern handle that is the AND of the two patterns provided<span class="co">.</span></a>
<a class="sourceLine" id="cb9-140" title="140">     <span class="co">*</span> The binding components will be the union of the binding components</a>
<a class="sourceLine" id="cb9-141" title="141">     <span class="co">*</span> of the two patterns<span class="co">.</span></a>
<a class="sourceLine" id="cb9-142" title="142">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-143" title="143">    <span class="dt">static</span>&lt;T&gt; __Pattern&lt;T&gt; <span class="fu">and</span>(<span class="bu">Class</span>&lt;T&gt; targetType,</a>
<a class="sourceLine" id="cb9-144" title="144">                                   __Pattern&lt;? <span class="kw">extends</span> T&gt; left,</a>
<a class="sourceLine" id="cb9-145" title="145">                                   __Pattern&lt;? <span class="kw">extends</span> T&gt; right) {</a>
<a class="sourceLine" id="cb9-146" title="146">        <span class="kw">return</span> __Patterns.<span class="fu">and</span>(targetType, left, right);</a>
<a class="sourceLine" id="cb9-147" title="147">    }</a>
<a class="sourceLine" id="cb9-148" title="148"></a>
<a class="sourceLine" id="cb9-149" title="149">    <span class="co">/**</span></a>
<a class="sourceLine" id="cb9-150" title="150">     <span class="co">*</span> Returns a pattern handle that matches the outer pattern and then</a>
<a class="sourceLine" id="cb9-151" title="151">     <span class="co">*</span> matches its binding components to the nested patterns<span class="co">. </span> The binding</a>
<a class="sourceLine" id="cb9-152" title="152">     <span class="co">*</span> components are the binding components of the outer pattern<span class="co">,</span> followed</a>
<a class="sourceLine" id="cb9-153" title="153">     <span class="co">*</span> by the binding components of each nested pattern<span class="co">.</span></a>
<a class="sourceLine" id="cb9-154" title="154">     <span class="co">*/</span></a>
<a class="sourceLine" id="cb9-155" title="155">    <span class="dt">static</span>&lt;T&gt; __Pattern&lt;T&gt; <span class="fu">nested</span>(__Pattern&lt;T&gt; outer, __Pattern<span class="kw">... </span>nested) {</a>
<a class="sourceLine" id="cb9-156" title="156">        <span class="kw">return</span> __Patterns.<span class="fu">nest</span>(outer, nested);</a>
<a class="sourceLine" id="cb9-157" title="157">    }</a></code></pre></div>
<h2 id="future-work">Future work</h2>
<p>This document focuses mostly on the compilation target, and on analysis of compatibility requirements. Deliberately left out topics include:</p>
<ul>
<li>Language syntax. While this is a very interesting topic, we prefer to lay a solid groundwork that captures runtime description, translation strategy, and migration compatibility before moving on to the far more subjective subject of defining a language syntax for describing patterns.</li>
<li>Switch classifiers. While some languages translate pattern switches into chains of if-else, it is often possible to do better, by performing a pre-computation (e.g., hashing) on the target, and strength-reducing to a traditional switch. (This generally must be tolerant of changes induced by recompilation, such as changed class hierarchies, so <code>indy</code> is likely called for here.) We anticipate being able to use class hierarchy information to optimize switches over subtypes of sealed hierarchies, and avoid redundant tests based on known type relationships. This problem will be addressed in a separate document.</li>
</ul>
<div class="footer" id="footer">
<img src="http://openjdk.java.net/images/openjdk-small.png">
<br>© 2021 Oracle Corporation and/or its affiliates
<br><a href="http://openjdk.java.net/legal/tou/">Terms of Use</a>
· License: <a href="http://openjdk.java.net/legal/gplv2+ce.html">GPLv2</a>
· <a href="http://www.oracle.com/us/legal/privacy/">Privacy</a>
· <a href="http://www.oracle.com/us/legal/third-party-trademarks/third-party-trademarks-078568.html">Trademarks</a>
</div>
</body>
</html>
