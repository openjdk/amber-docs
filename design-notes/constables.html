<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>constables</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
      <style type="text/css">
        A IMG { border-width: 0px; }
  
        BODY {
            background: white;
            margin: 2em;
          font-size: medium;
          max-width: 60em;
          margin-bottom: 100%;
          font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji;
        }
  
        code, pre, tt {
  	font-family: SFMono-Regular, Consolas, Liberation Mono, Menlo, monospace;
  	font-size: medium
        }
  
        code {
            display: inline-block;
            padding: .1em .2em;
          font-size: 90%;
          border-radius: 6px;
  	background-color: #f6f8fa;
          box-sizing: border-box;
        }
  
        h1 {
  	  font-size: 32px;
        }
  
        h1,
        h2 {
  	  font-weight: 600;
            border-bottom: 1px solid #e8e8e8;
        }
        
        h2 {
  	  font-size: 24px
        }
        
        h3 {
  	  font-size: 20px
        }
        
        h3,
        h4 {
  	  font-weight: 600
        }
        
        h4 {
  	  font-size: 20px
        }
  
        P { margin: 1ex 0em; }
        P.subsection { margin-top: 2ex; }
        P.subsection:first-child { margin-top: 1ex; }
        P SPAN.title { font-weight: bold; padding-right: 1em; }
  
        PRE {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #f6f8fa;
        }
  
        .sidebar {
          margin: 1.5ex 2em;
          padding: 1px 1ex;
          background: #e8e8e8;
        }
  
        .control-character {
            color: #bbb;
            font-style: italic;
        }
  
        /* added for ```{.jvm} support */
        PRE.jvm { font-style: italic; }
  
        BLOCKQUOTE { margin: 1.5ex 2em; font-style: italic; border-left: 0.2em solid gray; padding-left: 1em; }
        LI BLOCKQUOTE { margin-left: 0em; }
        LI { margin: 0ex 0em; }
  
        TABLE, TH, TD { border: 1px solid #e8e8e8;
                        padding: 6px 12px; }
        TR:nth-child(2n) {
            background-color: #f6f8fa;
        }
        TH { font-weight: 600 }
        TABLE { border-collapse: collapse; }
        TD { vertical-align: top; }
  
        UL LI { list-style-type: square; }
  
        DIV.summary { margin: 2ex 2em; }
  
        DIV.head { margin-bottom: 2em; }
        DIV.doctitle { font-size: x-large; font-weight: bold; }
        DIV.twarn { color: #cc0000; font-size: smaller; font-weight: bold;
                    margin-bottom: 1.5ex; }
        DIV.authors { margin-top: 1ex; font-size: large; }
        DIV.author A { font-style: italic; }
        DIV.version { font-size: medium; margin-top: 1ex; }
        DIV.copyright, DIV.comments { font-size: small; }
        DIV.version SPAN.modified { color: green; font-weight: bold; }
        DIV.head DIV.notes { margin-top: 1ex; }
        DIV.qa { margin-top: 2ex; }
        DIV.footer { padding-top: 4em; text-align: center; font-size: 7pt; }
        
        /* added because pandoc syntax highlighting always uses scroll bars */
        DIV.sourceCode {
            overflow: visible;
        }
  
        HR { border: 0px; border-top: 1px solid black; margin: 2ex 0em; }
     </style>
</head>
<body>
<h1 id="symbolic-references-for-constants">Symbolic References for Constants</h1>
<h4 id="brian-goetz-march-2018">Brian Goetz, March 2018</h4>
<p><a href="http://openjdk.java.net/jeps/303">JEP 303</a> exposes compiler intrinsics so that Java source code can deterministically generate <code>ldc</code> and <code>invokedynamic</code> bytecodes. Further, <a href="http://openjdk.java.net/jeps/309">JEP 309</a> defines a new loadable constant pool form, <code>CONSTANT_Dynamic</code>, where the constant is produced by linking a bootstrap method and invoking it. This document outlines JDK and compiler support for these feature. (This API is for low-level users; most users will never see this API.)</p>
<h2 id="background">Background</h2>
<p>The <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">JVM specification</a> defines a number of constant pool forms, a subset of which (the <em>loadable</em> constants) can be used as the operand of an <code>ldc</code> instruction or included in the static argument list of a bootstrap method. These correspond to the Java types <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>String</code>, <code>Class</code>, <code>MethodType</code>, and <code>MethodHandle</code> (and, soon, dynamically computed constants.) For each of these constant types, there is a corresponding “live” object type (<code>String</code>, <code>Class</code>.)</p>
<p>Activities such as bytecode generation have a frequent need to describe constants such as classes. However, a <code>Class</code> object is a poor description for an arbitrary class. Producing a <code>Class</code> instance has many environmental dependencies and failure modes; loading may fail in because the desired class does not exist or may not be accessible to the requestor, the result of loading varies with class loading context, loading classes has side-effects, and sometimes may not be possible at all (such as when the classes being described do not yet exist or are otherwise not loadable, as in during compilation of those same classes, or during <code>jlink</code>-time transformation.) So, while the <code>String</code> class is a fine description for a <code>Constant_String_info</code>, the <code>Class</code> type is not a very good description for a <code>Constant_Class_info</code>.</p>
<p>A number of activities share the need to deal with classes, methods, and other entities in a purely nominal form. Bytecode parsing and generation libraries must describe classes and method handles in symbolic form. Without an official mechanism, they must resort to ad-hoc mechanisms, whether descriptor types like ASM’s <code>Handle</code>, or tuples of strings (method owner, method name, method descriptor), or ad-hoc (and error-prone) encodings of these into a single string. Bootstraps for <code>invokedynamic</code> that operate by spinning bytecode (such as <code>LambdaMetafactory</code>) would prefer to work in a symbolic domain rather than with live classes and method handles. Compilers and offline transformers (such as <code>jlink</code> plugins) need to describe classes and members for classes that cannot be loaded into the running VM. Compiler plugins (such as annotation processors) similarly need to describe program elements in symbolic terms. They would all benefit from having a single, official way to describe such constants.</p>
<h4 id="symbolic-references">Symbolic references</h4>
<p>Our solution is to define a family of value-based <em>symbolic reference</em> (<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">JVMS</a> 5.1) types, capable of describing each kind of loadable constant. A symbolic reference describes a constant in purely nominal form, separate from class loading or accessibility context. Some classes can act as their own symbolic references (e.g., <code>String</code>); for linkable constants we define a family of symbolic reference types (<code>ClassRef</code>, <code>MethodTypeRef</code>, <code>MethodHandleRef</code>, and <code>DynamicConstantRef</code>) that contain the nominal information to describe these constants.</p>
<h2 id="constantref">ConstantRef</h2>
<p>The symbolic reference API lives in the package <code>java.lang.invoke.constant</code>. The basic new abstraction is the <code>ConstantRef&lt;T&gt;</code> interface, which indicates that a class acts as a symbolic reference for a constant whose live type is <code>T</code>, and supports reflective resolution of constants, given a <code>Lookup</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> ConstantRef&lt;T&gt; {</a>
<a class="sourceLine" id="cb1-2" title="2">    T <span class="fu">resolveConstantRef</span>(MethodHandles.<span class="fu">Lookup</span> lookup)</a>
<a class="sourceLine" id="cb1-3" title="3">        <span class="kw">throws</span> ReflectiveOperationException;</a>
<a class="sourceLine" id="cb1-4" title="4">}</a></code></pre></div>
<p>The classes <code>String</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, and <code>Double</code> act as <code>ConstantRef</code> for themselves. Additionally, we provide interfaces <code>ClassRef</code>, <code>MethodTypeRef</code>, and <code>MethodHandleRef</code> to represent <code>Class</code>, <code>MethodType</code>, and <code>MethodHandle</code>, and concrete implementations <code>ConstantClassRef</code>, <code>ConstantMethodHandleRef</code>, and <code>ConstantMethodTypeRef</code> that correspond to the constant pool forms of similar name. We also provide <code>DynamicConstantRef</code> for dynamic (bootstrap-generated) constants.</p>
<p><code>ConstantRef</code> can be used in APIs that wish to constrain their input or output to be symbolic references to classfile constants; such uses arise naturally in the intrinsification API, the API for describing <code>invokedynamic</code> bootstrap specifiers, bytecode APIs, compiler plugin APIs, etc.</p>
<h4 id="classref">ClassRef</h4>
<p>A <code>ClassRef</code> describes a <code>Class</code> (including the <code>Class</code> mirrors associated with non-reference types, like <code>int.class</code>, and array classes.) <code>ClassRef</code> provides factories for creating class references, accessors for its state, and combinators to create new class references (such as going between a component type and the corresponding array type.)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> ClassRef <span class="kw">extends</span> ConstantRef&lt;<span class="bu">Class</span>&lt;?&gt;&gt; {</a>
<a class="sourceLine" id="cb2-2" title="2">    <span class="co">// Factories</span></a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="dt">static</span> ClassRef <span class="fu">of</span>(<span class="bu">String</span> name);</a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="dt">static</span> ClassRef <span class="fu">of</span>(<span class="bu">String</span> packageName, <span class="bu">String</span> className);</a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="dt">static</span> ClassRef <span class="fu">ofDescriptor</span>(<span class="bu">String</span> descriptor);</a>
<a class="sourceLine" id="cb2-6" title="6"></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="co">// Combinators</span></a>
<a class="sourceLine" id="cb2-8" title="8">    ClassRef <span class="fu">array</span>();</a>
<a class="sourceLine" id="cb2-9" title="9">    ClassRef <span class="fu">inner</span>(<span class="bu">String</span> innerName);</a>
<a class="sourceLine" id="cb2-10" title="10">    ClassRef <span class="fu">inner</span>(<span class="bu">String</span> firstInnerName, <span class="bu">String</span><span class="kw">... </span>moreInnerNames);</a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12">    <span class="co">// Accessors</span></a>
<a class="sourceLine" id="cb2-13" title="13">    <span class="dt">boolean</span> <span class="fu">isArray</span>();</a>
<a class="sourceLine" id="cb2-14" title="14">    <span class="dt">boolean</span> <span class="fu">isPrimitive</span>();</a>
<a class="sourceLine" id="cb2-15" title="15">    ClassRef <span class="fu">componentType</span>();</a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="kw">default</span> <span class="bu">String</span> <span class="fu">simpleName</span>();</a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="bu">String</span> <span class="fu">descriptorString</span>();</a>
<a class="sourceLine" id="cb2-18" title="18">}</a></code></pre></div>
<p>Because some class mirrors are represented in the constant pool using <code>Constant_Class_info</code>, and others (primitives) are represented using dynamic constants, there are multiple concrete implementations of <code>ClassRef</code>.</p>
<h4 id="methodtyperef">MethodTypeRef</h4>
<p>A <code>MethodTypeRef</code> describes a <code>MethodType</code>; <code>MethodTypeRef</code> uses <code>ClassRef</code> to describe the parameter and return types. <code>MethodTypeRef</code> includes a similar set of combinators as <code>MethodType</code> for modifying return and parameter types, so that bootstraps that want to work symbolically can perform similar operations as bootstraps that work on live objects.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> MethodTypeRef <span class="kw">extends</span> ConstantRef&lt;MethodType&gt; {</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co">// Factories</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="dt">static</span> MethodTypeRef <span class="fu">ofDescriptor</span>(<span class="bu">String</span> descriptor);</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="dt">static</span> MethodTypeRef <span class="fu">of</span>(ClassRef returnDescriptor, ClassRef<span class="kw">... </span>paramDescriptors);</a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="co">// Accessors</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="bu">String</span> <span class="fu">descriptorString</span>();</a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="bu">String</span> <span class="fu">simpleDescriptor</span>();</a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="dt">int</span> <span class="fu">parameterCount</span>();</a>
<a class="sourceLine" id="cb3-10" title="10">    ClassRef <span class="fu">parameterType</span>(<span class="dt">int</span> index);</a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="bu">List</span>&lt;ClassRef&gt; <span class="fu">parameterList</span>();</a>
<a class="sourceLine" id="cb3-12" title="12">    ClassRef[] <span class="fu">parameterArray</span>();</a>
<a class="sourceLine" id="cb3-13" title="13"></a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="co">// Combinators</span></a>
<a class="sourceLine" id="cb3-15" title="15">    MethodTypeRef <span class="fu">changeReturnType</span>(ClassRef returnType);</a>
<a class="sourceLine" id="cb3-16" title="16">    MethodTypeRef <span class="fu">changeParameterType</span>(<span class="dt">int</span> index, ClassRef paramType);</a>
<a class="sourceLine" id="cb3-17" title="17">    MethodTypeRef <span class="fu">dropParameterTypes</span>(<span class="dt">int</span> start, <span class="dt">int</span> end);</a>
<a class="sourceLine" id="cb3-18" title="18">    MethodTypeRef <span class="fu">insertParameterTypes</span>(<span class="dt">int</span> pos, ClassRef<span class="kw">... </span>paramTypes);</a>
<a class="sourceLine" id="cb3-19" title="19">}</a></code></pre></div>
<h4 id="methodhandleref">MethodHandleRef</h4>
<p>A <code>MethodHandleRef</code> describes a method handle. It can describe both direct method handles (<code>ConstantMethodHandleRef</code>) and derived method handles; accessors for properties of direct method handles are defined on <code>ConstantMethodHandleRef</code>.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> MethodHandleRef <span class="kw">extends</span> ConstantRef&lt;MethodHandle&gt; {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="kw">enum</span> Kind {</a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="at">@Foldable</span> <span class="fu">STATIC</span>(REF_invokeStatic),</a>
<a class="sourceLine" id="cb4-4" title="4">        <span class="at">@Foldable</span> <span class="fu">VIRTUAL</span>(REF_invokeVirtual),</a>
<a class="sourceLine" id="cb4-5" title="5">        <span class="at">@Foldable</span> <span class="fu">INTERFACE_VIRTUAL</span>(REF_invokeInterface),</a>
<a class="sourceLine" id="cb4-6" title="6">        <span class="at">@Foldable</span> <span class="fu">SPECIAL</span>(REF_invokeSpecial),</a>
<a class="sourceLine" id="cb4-7" title="7">        <span class="at">@Foldable</span> <span class="fu">CONSTRUCTOR</span>(REF_newInvokeSpecial),</a>
<a class="sourceLine" id="cb4-8" title="8">        <span class="at">@Foldable</span> <span class="fu">GETTER</span>(REF_getField),</a>
<a class="sourceLine" id="cb4-9" title="9">        <span class="at">@Foldable</span> <span class="fu">SETTER</span>(REF_putField),</a>
<a class="sourceLine" id="cb4-10" title="10">        <span class="at">@Foldable</span> <span class="fu">STATIC_GETTER</span>(REF_getStatic),</a>
<a class="sourceLine" id="cb4-11" title="11">        <span class="at">@Foldable</span> <span class="fu">STATIC_SETTER</span>(REF_putStatic);</a>
<a class="sourceLine" id="cb4-12" title="12"></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="co">// Factories</span></a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="dt">static</span> ConstantMethodHandleRef <span class="fu">of</span>(Kind kind, ClassRef clazz, <span class="bu">String</span> name, MethodTypeRef type);</a>
<a class="sourceLine" id="cb4-15" title="15">    <span class="dt">static</span> ConstantMethodHandleRef <span class="fu">of</span>(Kind kind, ClassRef clazz, <span class="bu">String</span> name, <span class="bu">String</span> descriptorString);</a>
<a class="sourceLine" id="cb4-16" title="16">    <span class="dt">static</span> ConstantMethodHandleRef <span class="fu">of</span>(Kind kind, ClassRef clazz, <span class="bu">String</span> name, ClassRef returnType, ClassRef<span class="kw">... </span>paramTypes);</a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="dt">static</span> ConstantMethodHandleRef <span class="fu">ofField</span>(Kind kind, ClassRef clazz, <span class="bu">String</span> name, ClassRef type);</a>
<a class="sourceLine" id="cb4-18" title="18"></a>
<a class="sourceLine" id="cb4-19" title="19">    <span class="co">// Accessors</span></a>
<a class="sourceLine" id="cb4-20" title="20">    <span class="fu">methodType</span>();</a>
<a class="sourceLine" id="cb4-21" title="21"></a>
<a class="sourceLine" id="cb4-22" title="22">    <span class="co">// Combinators</span></a>
<a class="sourceLine" id="cb4-23" title="23">    MethodHandleRef <span class="fu">asType</span>(MethodTypeRef type);</a>
<a class="sourceLine" id="cb4-24" title="24">}</a>
<a class="sourceLine" id="cb4-25" title="25"></a>
<a class="sourceLine" id="cb4-26" title="26"><span class="kw">public</span> <span class="kw">class</span> ConstantMethodHandleRef <span class="kw">implements</span> MethodHandleRef {</a>
<a class="sourceLine" id="cb4-27" title="27">    <span class="co">// Accessors</span></a>
<a class="sourceLine" id="cb4-28" title="28">    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">refKind</span>();</a>
<a class="sourceLine" id="cb4-29" title="29">    <span class="kw">public</span> Kind <span class="fu">kind</span>();</a>
<a class="sourceLine" id="cb4-30" title="30">    <span class="kw">public</span> ClassRef <span class="fu">owner</span>();</a>
<a class="sourceLine" id="cb4-31" title="31">    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">methodName</span>();</a>
<a class="sourceLine" id="cb4-32" title="32">    <span class="kw">public</span> MethodTypeRef <span class="fu">methodType</span>();</a>
<a class="sourceLine" id="cb4-33" title="33">}</a></code></pre></div>
<h4 id="dynamicconstantref">DynamicConstantRef</h4>
<p>A <code>DynamicConstantRef</code> describes a dynamic constant in terms of a bootstrap method, bootstrap arguments, and invocation name and type.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">public</span> <span class="kw">class</span> DynamicConstantRef&lt;T&gt; <span class="kw">implements</span> ConstantRef&lt;T&gt; {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="co">// Factories</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="dt">static</span>&lt;T&gt; DynamicConstantRef&lt;T&gt; <span class="fu">of</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name, ClassRef type, ConstantRef&lt;?&gt;[] bootstrapArgs);</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="dt">static</span>&lt;T&gt; DynamicConstantRef&lt;T&gt; <span class="fu">of</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name, ClassRef type);</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="dt">static</span>&lt;T&gt; DynamicConstantRef&lt;T&gt; <span class="fu">of</span>(MethodHandleRef bootstrapMethod, ClassRef type);</a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="dt">static</span>&lt;T&gt; DynamicConstantRef&lt;T&gt; <span class="fu">of</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name);</a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="dt">static</span>&lt;T&gt; DynamicConstantRef&lt;T&gt; <span class="fu">of</span>(MethodHandleRef bootstrapMethod);</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="dt">static</span>&lt;T&gt; ConstantRef&lt;T&gt; <span class="fu">ofCanonical</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name, ClassRef type, ConstantRef&lt;?&gt;[] bootstrapArgs);</a>
<a class="sourceLine" id="cb5-9" title="9"></a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="co">// Combinators</span></a>
<a class="sourceLine" id="cb5-11" title="11">    <span class="kw">public</span> DynamicConstantRef&lt;T&gt; <span class="fu">withArgs</span>(ConstantRef&lt;?&gt;<span class="kw">... </span>bootstrapArgs);</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="co">// Accessors</span></a>
<a class="sourceLine" id="cb5-14" title="14">    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">constantName</span>();</a>
<a class="sourceLine" id="cb5-15" title="15">    <span class="kw">public</span> ClassRef <span class="fu">constantType</span>();</a>
<a class="sourceLine" id="cb5-16" title="16">    <span class="kw">public</span> MethodHandleRef <span class="fu">bootstrapMethod</span>();</a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="kw">public</span> ConstantRef&lt;?&gt;[] <span class="fu">bootstrapArgs</span>();</a>
<a class="sourceLine" id="cb5-18" title="18">}</a></code></pre></div>
<p>There are also subtypes of <code>DynamicConstantRef</code> for describing important runtime types such as enums (<code>EnumRef</code>) and <code>VarHandle</code>s (<code>VarHandleRef</code>). The class <code>ConstantRefs</code> defines useful symbolic references such as <code>CR_int</code> (a <code>ClassRef</code> describing the primitive type <code>int</code>) or <code>NULL</code> (describing the null value).</p>
<h4 id="bytecode-writing-and-reading">Bytecode writing and reading</h4>
<p>If a compiler or bytecode API uses symbolic references to describe constants, it will have to be able to write constants described by <code>ConstantRef</code> to the constant pool, and translate entries read from the constant pool to <code>ConstantRef</code>. For each type of constant pool entry, there is a corresponding concrete symbolic reference type, so a bytecode writer need only case over the types corresponding to each constant pool entry, cast to the appropriate type, and call the appropriate accessor methods. A bytecode reader would case over the constant pool types, and call the appropriate <code>XxxRef</code> factory method.</p>
<p>For dynamic constants whose bootstraps are “well-known”, the library will lift dynamic constants to the appropriate subtype, if asked (via the <code>DynamicConstantRef.ofCanonical()</code> method.) For example, a dynamic constant describing the primitive type <code>int.class</code> using the bootstrap <code>ConstantBootstraps.primitiveType()</code> will be lifted to a <code>ClassRef</code> for <code>int</code>; a dynamic constant describing an <code>enum</code> via the bootstrap <code>ConstantBootstraps.enumConstant()</code> will be lifted to an <code>EnumRef</code>. Bytecode reading libraries need only materialize dynamic constants using the <code>ofCanonical()</code> factory to deliver strongly typed symbolic references to their clients.</p>
<h4 id="extensibility">Extensibility</h4>
<p>The <code>ConstantRef</code> hierarchy will eventually be sealed (prohibiting new direct subtypes beyond the ones defined), but the <code>DynamicConstantRef</code> type will be left open for extension. Creating a symbolic reference type for an arbitrary type <code>T</code> can be done by creating a subtype of <code>DynamicConstantRef</code>, providing factories for describing the instances in nominal form, and implementing the <code>resolveConstantRef()</code> method. This is how <code>EnumRef</code> and <code>VarHandleRef</code> are implemented.</p>
<h4 id="representing-invokedynamic-sites">Representing invokedynamic sites</h4>
<p>Call sites for <code>invokedynamic</code> are defined similarly to dynamic constants, with <code>DynamicCallSiteRef</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">public</span> <span class="dt">final</span> <span class="kw">class</span> DynamicCallSiteRef {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="co">// Factories</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">public</span> <span class="dt">static</span> DynamicCallSiteRef <span class="fu">ofCanonical</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name, MethodTypeRef type,</a>
<a class="sourceLine" id="cb6-4" title="4">                                                 ConstantRef&lt;?&gt;<span class="kw">... </span>bootstrapArgs);</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="kw">public</span> <span class="dt">static</span> DynamicCallSiteRef <span class="fu">of</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name, MethodTypeRef type,</a>
<a class="sourceLine" id="cb6-6" title="6">                                        ConstantRef&lt;?&gt;<span class="kw">... </span>bootstrapArgs);</a>
<a class="sourceLine" id="cb6-7" title="7">    <span class="kw">public</span> <span class="dt">static</span> DynamicCallSiteRef <span class="fu">of</span>(MethodHandleRef bootstrapMethod, <span class="bu">String</span> name, MethodTypeRef type);</a>
<a class="sourceLine" id="cb6-8" title="8">    <span class="kw">public</span> <span class="dt">static</span> DynamicCallSiteRef <span class="fu">of</span>(MethodHandleRef bootstrapMethod, MethodTypeRef type);</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="co">// Combinators</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="kw">public</span> DynamicCallSiteRef <span class="fu">withNameAndType</span>(<span class="bu">String</span> name, MethodTypeRef type);</a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="kw">public</span> DynamicCallSiteRef <span class="fu">withArgs</span>(ConstantRef&lt;?&gt;<span class="kw">... </span>bootstrapArgs);</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14">    <span class="co">// Accessors</span></a>
<a class="sourceLine" id="cb6-15" title="15">    <span class="kw">public</span> <span class="bu">String</span> <span class="fu">name</span>();</a>
<a class="sourceLine" id="cb6-16" title="16">    <span class="kw">public</span> MethodTypeRef <span class="fu">type</span>();</a>
<a class="sourceLine" id="cb6-17" title="17">    <span class="kw">public</span> MethodHandleRef <span class="fu">bootstrapMethod</span>();</a>
<a class="sourceLine" id="cb6-18" title="18">    <span class="kw">public</span> ConstantRef&lt;?&gt;[] <span class="fu">bootstrapArgs</span>();</a>
<a class="sourceLine" id="cb6-19" title="19"></a>
<a class="sourceLine" id="cb6-20" title="20">    <span class="co">// Reflection</span></a>
<a class="sourceLine" id="cb6-21" title="21">    <span class="kw">public</span> MethodHandle <span class="fu">dynamicInvoker</span>(MethodHandles.<span class="fu">Lookup</span> lookup);</a></code></pre></div>
<h2 id="intrinsics">Intrinsics</h2>
<p>When the <code>invokedynamic</code> bytecode was introduced in Java SE 7, it was largely intended to be used as a compilation target; no provision was made for directly accessing the functionality of <code>invokedynamic</code> from Java source code, except through the reflective <code>dynamicInvoker()</code> mechanism. Over time, as more library functionality was exposed through bootstrap methods, it became more desirable to be able to express <code>invokedynamic</code> directly in Java source. In turn, this requires being able to describe the bootstrap method handle, and the static bootstrap arguments, as classfile constants. And, with the introduction of <code>Constant_Dynamic</code> (condy) in JEP 309, there are additional forms of classfile constants that would be convenient to express from Java source code.</p>
<p>Our approach is to expose methods that correspond to the <code>ldc</code> and <code>invokedynamic</code> instructions, that the compiler can deterministically <em>intrinsify</em> into the appropriate bytecode instruction, thus allowing Java source code to directly express these instructions and reason confidently about their translation by the compiler.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">public</span> <span class="kw">class</span> Intrinsics {</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="kw">public</span> <span class="dt">static</span> &lt;T&gt; T <span class="fu">ldc</span>(ConstantRef&lt;T&gt; constant) { <span class="kw">... </span>}</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">public</span> <span class="dt">static</span> <span class="bu">Object</span> <span class="fu">invokedynamic</span>(DynamicCallSiteRef site,</a>
<a class="sourceLine" id="cb7-5" title="5">                                       <span class="bu">Object</span><span class="kw">... </span>dynamicArgs)</a>
<a class="sourceLine" id="cb7-6" title="6">            <span class="kw">throws</span> <span class="bu">Throwable</span> { <span class="kw">... </span>}</a>
<a class="sourceLine" id="cb7-7" title="7">}</a></code></pre></div>
<p>When intrinsifying an <code>ldc()</code> call, the compiler must first ensure that the arguments provided are compile-time constants, so that it can emit the appropriate entries into the constant pool of the class being generated, which it does by introspecting on the contents of the <code>ConstantRef</code> passed to <code>ldc()</code>.</p>
<p>Similarly, when intrinsifying an <code>invokedynamic</code>, the compiler will ensure that the <code>DynamicCallSiteRef</code> argument is a compile-time constants, and then use its contents generate an <code>invokedynamic</code> instruction and the corresponding entries in the constant pool and <code>BootstrapMethods</code> attribute. Since the <code>DynamicCallSiteRef</code> contains the <code>MethodType</code> for the invocation, the compiler will use that to determine the compile-time type of the result (unlike signature-polymorphic invocation, which cast context to condition the return type.)</p>
<h4 id="examples">Examples</h4>
<p>If we want to load the method handle for <code>String::isEmpty</code>, we could do as follows, which would translate as an <code>ldc</code> of a <code>MethodHandle</code> constant.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb8-1" title="1">MethodTypeRef mtr = MethodTypeRef.<span class="fu">of</span>(CR_void);</a>
<a class="sourceLine" id="cb8-2" title="2">MethodHandleRef mhr = MethodHandleRef.<span class="fu">of</span>(VIRTUAL, CR_String, <span class="st">&quot;isEmpty&quot;</span>, mtr);</a>
<a class="sourceLine" id="cb8-3" title="3">...</a>
<a class="sourceLine" id="cb8-4" title="4">MethodHandle mh = Intrinsics.<span class="fu">ldc</span>(mhr);</a></code></pre></div>
<p>Similarly, we can load a dynamic constant, but we must first know the bootstrap method (and describe it as a <code>MethodHandleRef</code>.) To load an <code>enum</code> constant, we could just <code>ldc</code> an <code>EnumRef</code> constant, but here’s what it looks like using the <code>enumConstant()</code> bootstrap directly:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">public</span> <span class="dt">static</span> &lt;T <span class="kw">extends</span> <span class="bu">Enum</span>&lt;T&gt;&gt; T <span class="fu">enumConstant</span>(Lookup lookup,</a>
<a class="sourceLine" id="cb9-2" title="2">                                                 <span class="bu">String</span> name,</a>
<a class="sourceLine" id="cb9-3" title="3">                                                 <span class="bu">Class</span>&lt;T&gt; type);</a></code></pre></div>
<p>We create a <code>DynamicConstantRef</code> to describe the desired constant:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb10-1" title="1"><span class="co">// Convenience method inserts the standard condy preamble</span></a>
<a class="sourceLine" id="cb10-2" title="2">MethodHandleRef bsm</a>
<a class="sourceLine" id="cb10-3" title="3">    = MethodHandleRef.<span class="fu">ofDynamicConstant</span>(ClassRef.<span class="fu">of</span>(<span class="st">&quot;MyBootstraps&quot;</span>), <span class="st">&quot;enumConstant&quot;</span>);</a>
<a class="sourceLine" id="cb10-4" title="4">DynamicConstantRef ElementType_METHOD</a>
<a class="sourceLine" id="cb10-5" title="5">    = DynamicConstantRef.<span class="fu">of</span>(bsm, <span class="st">&quot;METHOD&quot;</span>, ClassRef.<span class="fu">of</span>(<span class="st">&quot;java.lang.ElementType&quot;</span>));</a>
<a class="sourceLine" id="cb10-6" title="6">...</a>
<a class="sourceLine" id="cb10-7" title="7"><span class="bu">ElementType</span> et = Intrinsics.<span class="fu">ldc</span>(ElementType_METHOD);</a></code></pre></div>
<p>Suppose we have an <code>invokedynamic</code> bootstrap method:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">public</span> <span class="dt">static</span> CallSite <span class="fu">returnsStaticArg</span>(MethodHandles.<span class="fu">Lookup</span> lookup,</a>
<a class="sourceLine" id="cb11-2" title="2">                                        <span class="bu">String</span> invocationName,</a>
<a class="sourceLine" id="cb11-3" title="3">                                        MethodType invocationType,</a>
<a class="sourceLine" id="cb11-4" title="4">                                        <span class="bu">String</span> arg) {</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="kw">return</span> <span class="kw">new</span> <span class="fu">ConstantCallSite</span>(MethodHandles.<span class="fu">constant</span>(<span class="bu">String</span>.<span class="fu">class</span>, arg));</a>
<a class="sourceLine" id="cb11-6" title="6">}</a></code></pre></div>
<p>which takes a static string argument, and links a callsite that just always returns that string.</p>
<p>We can express an <code>invokedynamic</code> site for this in Java source with:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb12-1" title="1">ClassRef owner = ClassRef.<span class="fu">of</span>(<span class="st">&quot;HelperClass&quot;</span>);</a>
<a class="sourceLine" id="cb12-2" title="2">MethodHandleRef bsm</a>
<a class="sourceLine" id="cb12-3" title="3">    = MethodHandleRef.<span class="fu">ofDynamicCallSite</span>(owner, <span class="st">&quot;returnsStaticArg&quot;</span>,</a>
<a class="sourceLine" id="cb12-4" title="4">                                        CR_String, CR_String);</a>
<a class="sourceLine" id="cb12-5" title="5">...</a>
<a class="sourceLine" id="cb12-6" title="6"><span class="bu">String</span> s = Intrinsics.<span class="fu">invokedynamic</span>(bsm, <span class="st">&quot;theString&quot;</span>);</a></code></pre></div>
<h2 id="constant-tracking-propagation-and-folding">Constant tracking, propagation, and folding</h2>
<p>The arguments provided to <code>Intrinsics</code> calls must be compile-time constants. However, in the examples we’ve seen, they are the result of calling factory methods like <code>ClassRef.of()</code>, which don’t qualify as constants. So, what’s going on?</p>
<p>To implement our <code>Intrinsics</code> support, we extend the definition of compile-time constant, and improve the compiler’s ability to do constant propagation and folding. The language has an existing notion of compile-time constant; rather than extend this notion, which would interact with <code>ConstantValue</code> treatment (inlining of constants across compilation units), we define an extended notion of compile-time constant-ness called a <em>trackable constant</em> (TC). To start with:</p>
<ul>
<li>String and numeric literals are TC.</li>
<li>Arithmetic combinations of TC are TC.</li>
<li>Effectively final locals whose initializers are TC are TC.</li>
<li>Static final fields <em>within the same compilation unit</em> whose initializers are TC are TC.</li>
</ul>
<h4 id="tracking">Tracking</h4>
<p>Rather than go right to constant folding or propagation, we use a technique called <em>constant tracking</em> that is more flexible. For each AST node, if the expression that the node describes is TC, the compiler evaluates the constant at compile time and associates the constant value with its node. For example, the node that describes a string literal stores a corresponding <code>String</code> instance as the tracked value of that node. When the compiler encounters a string concatenation operation, both of whose operand nodes have a tracked value, it computes the concatenation of that value, and tracks that value with the concatenation node. The compiler can then use the tracked value in later operations, or not; it can fold the node to its constant value, propagate the constant, or fall back to tree analysis and bytecode generation as it sees fit. Constant tracking broadens the reach of existing constant-based optimizations; we have always folded things like <code>"a" + "b"</code>, but until now we haven’t been willing to flow known constants through static final fields or effectively final locals to expose more opportunities for folding.</p>
<p>Constant tracking is inherently partial; there are many reasons a constant cannot be computed at compile time. If the attempt to compute a tracked values fails, the node simply has no tracked value, and is therefore not TC. For example, for the expression <code>12/0</code>, while the compiler ordinarily folds simple arithmetic expressions on constants, if doing so would cause an exception, it simply treats the expression as not a constant and generates bytecode to compute <code>12/0</code> (which will surely throw at runtime) instead.</p>
<p>Intrinsification uses constant tracking in the obvious way: if the node corresponding to the arguments of an intrinsic does not have a tracked value, it is an error, and if it does, the compiler introspects on that value to generate the correct code.</p>
<p>Obviously, better support for identification, propagation, and folding of constants is useful for far beyond mere intrinsification of constants.</p>
<h4 id="constant-propagation">Constant propagation</h4>
<p>Tracking also enables us to perform <em>constant propagation</em>. In the following code:</p>
<pre><code>String s = &quot;Foo&quot;;
...
m(s);</code></pre>
<p>We would normally translate this as:</p>
<pre><code>ldc &quot;Foo&quot;
astore n
...
aload n
invokestatic m</code></pre>
<p>However, if we know that <code>s</code> is TC (because it is an effectively final local with an TC initializer), rather than fetching from <code>s</code>, we can directly propagate the known constant value instead. Rather than loading its value from the local variable, we can load it directly from the constant pool, so the second line translate to:</p>
<pre><code>ldc &quot;Foo&quot;
invokestatic m</code></pre>
<p>By propagating constants to their points of use, we reduce the complexity of the data flow and expose opportunities for other optimizations, such as dead code elimination.</p>
<h4 id="foldable">Foldable</h4>
<p>To complete the story of why intrinsification works, we have to add some more ways to generate TC constants. We mark certain methods, including certain static factories, accessors, and combinators in the <code>ConstantRef</code> types, as “foldable”:</p>
<ul>
<li>Invocations of foldable methods applied to TC constants (and receiver, if applicable) are TC.</li>
<li>Loads of foldable static final fields across compilation units are TC.</li>
</ul>
<p>To mark a method or field as foldable, the current prototype uses the <code>@Foldable</code> annotation. The constraints on foldable methods are high; in order for constant-folding such invocations to be semantically equivalent, the method must be free of observable side-effects (since it might well get folded away) and be a pure function of its inputs (and receiver.) A foldable method applied to TC arguments (and with an TC receiver, if an instance method) can be evaluated at compile time reflectively using the tracked values of the arguments and receiver. (Obviously that means that the foldable code must be on the classpath during compilation; currently <code>@Foldable</code> is restricted to <code>java.base</code>.) If the reflective invocation completes successfully, the result is tracked with the invocation node.</p>
<h4 id="intrinsification">Intrinsification</h4>
<p>The arguments to the intrinsics methods <code>ldc()</code> and <code>invokedynamic()</code>, with the exception of the dynamic arguments to <code>invokedynamic</code> (the last <code>Object...</code> argument), must be TC. This means the trees associated with their arguments must have tracked constants associated with them. If they do not, it is a compile-time error, and the compiler issues an error identifying which argument was non-constant; if they do, the tree is replaced with a <code>ldc()</code> node, with constant information scraped from the argument, which must be <code>String</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>ConstantClassRef</code>, <code>ConstantMethodTypeRef</code>, <code>ConstantMethodHandleRef</code>, or <code>DynamicConstantRef</code>. The compiler will reflectively inspect the arguments, test them against these types, and cast them to the appropriate type and call the appropriate accessor methods to extract class names, descriptor strings, etc, and write them to the classfile.</p>
<h4 id="constable">Constable</h4>
<p>So far, we’ve made relatively little use of the tracked constants, other than to intrinsify <code>ldc()</code> and <code>invokedynamic()</code>, and to propagate string and numeric constants. In order to do more, we need to be able to map back from tracked values (including the result of reflective evaluation of foldable methods and fields) to constants that can be described in the constant pool. Just as a <code>ConstantRef</code> has a <code>resolveConstantRef()</code> method that allows you to reflectively go from the nominal constant description to the live object it describes, <code>Constable</code> provides the reverse direction. A type is <code>Constable</code> if it can produce a <code>ConstantRef</code> to describe its live values.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">public</span> <span class="kw">interface</span> Constable&lt;T&gt; {</a>
<a class="sourceLine" id="cb16-2" title="2">    Optional&lt;? <span class="kw">extends</span> ConstantRef&lt;? <span class="kw">super</span> T&gt;&gt; <span class="fu">toConstantRef</span>(MethodHandles.<span class="fu">Lookup</span> lookup);</a>
<a class="sourceLine" id="cb16-3" title="3">}</a></code></pre></div>
<p>The types <code>String</code>, <code>Integer</code>, <code>Long</code>, <code>Float</code>, <code>Double</code>, <code>Class</code>, <code>MethodType</code>, <code>MethodHandle</code>, <code>Enum</code>, and <code>VarHandle</code> have been fitted to implement <code>Constable</code>. As with <code>@Foldable</code>, the bar for <code>Constable</code> is high; the effect of loading the constant described by <code>toConstantRef()</code> must be identical, in value and observable side-effects, as executing the path by which the <code>Constable</code> was created.</p>
<h4 id="constant-folding">Constant folding</h4>
<p>With the addition of <code>Constable</code>, we are finally ready to perform more comprehensive compile-time constant folding. If a node has a tracked value, and it is an instance of <code>Constable</code>, we can attempt to convert it to a <code>ConstantRef</code> (a partial operation), and, if that succeeds, fold the node into an <code>ldc</code> of the corresponding <code>ConstantRef</code>. (Not all <code>@Foldable</code> methods must yield a <code>Constable</code>; builder instances may not be <code>Constable</code> themselves, but if their <code>build()</code> method produces a <code>Constable</code>, we can constant-fold that.)</p>
<p>As an example, consider this code:</p>
<pre><code>ClassRef cr1 = ClassRef.of(&quot;java.lang.String&quot;);
ClassRef cr2 = cr1.array();
System.out.println(cr2.descriptorString());</code></pre>
<p>Because <code>ClassRef.of()</code> is <code>@Foldable</code> and its argument is constant, the compiler reflectively invokes it and tracks the resulting <code>ClassRef</code> (which represents <code>String</code>) with the invocation node, and propagates that value into the symbol for the effectively-final variable <code>cr1</code>. At the next line, we can repeat the process; the receiver <code>cr1</code> is a constant, so we can invoke the foldable <code>array()</code> method, and get the <code>ClassRef</code> for <code>String[]</code>, and track that with <code>cr2</code>. Finally, <code>descriptorString()</code> is also foldable, and yields a <code>String</code>, which is <code>Constable</code> (its <code>toConstantRef()</code> returns itself, since <code>String</code> and friends act as their own nominal descriptor.) At this point, we can fold away the tree for <code>cr2.descriptorString()</code>, and replace it with an <code>ldc</code> of the descriptor string pulled out of <code>cr2</code> at compile time, <code>[Ljava/lang/String;</code>.</p>
<h4 id="dead-code-elimination">Dead code elimination</h4>
<p>Having done constant propagation and folding, the local variables <code>cr1</code> and <code>cr2</code> are now effectively unused, and their initializers (because we know the properties of the <code>ConstantRef</code> classes) are known to be side-effect free. So both the variables and their initializers can be eliminated entirely, and the above snippet compiles to:</p>
<pre><code>getfield System::out
ldc `[Ljava/lang/String;`
invokevirtual println(String)V</code></pre>
<p>If the initializers were <code>Constable</code> but not <code>ConstantRef</code>, we couldn’t completely eliminate the initializers (they might have side effects such as loading and initializing classes), but we cans still replace the initializer with an <code>ldc</code> of the constant described by the result of <code>Constable.toConstantRef()</code> – which will still likely be more efficient and compact than emitting the corresponding bytecode.</p>
<h4 id="path-optimization">Path optimization</h4>
<p>If the result of <code>cr2</code> were used elsewhere, compile-time folding would still pays dividends, because we can optimize the path by which <code>cr2</code> is created. The source code first creates a <code>ClassRef</code> for <code>String</code> and then uses it to derive a <code>ClassRef</code> for <code>String[]</code>. But if you examine the <code>ConstantRef</code> that results from calling <code>toConstantRef()</code> on <code>cr2</code>, you’ll see that it corresponds to an invocation (via condy) of <code>ClassRef.ofDescriptor("[Ljava/lang/String;")</code>. So if we fold other uses of <code>cr2</code> to an <code>ldc</code> of this <code>ClassRef</code>, not only do we get the caching and sharing that the constant pool gives us for free, but the initialization takes a more optimal path (going straight to <code>String[]</code>, rather than the indirect path through <code>String</code>.) In this way, builder-like APIs can fold at compile time and we only need to reproduce the end result as a constant, not the full path by which it was computed. (The burden is on such <code>@Foldable</code> and <code>Constable</code> APIs to ensure that this difference is not observable, except as a performance improvement.)</p>
<h4 id="string-folding">String folding</h4>
<p>Exposing a <code>constexpr</code>-like mechanism for <code>java.base</code> can be used as part of our language evolution strategy. In <a href="http://openjdk.java.net/jeps/326">JEP 326</a>, which adds raw (and multi-line) string literals to the Java language, the issue of indentation trimming came up – if we have a multi-line snippet of HTML embedded in a Java string, the indentation of the HTML may not be what is wanted, as it will include the indentation of the HTML <em>plus</em> the indentation of the Java. Some people wanted the compiler to implement a complex algorithm to normalize the indentation, but the language is not the place for this; it is unlikely than any one normalization algorithm will satisfy all comers, and it adds complexity to the language. Better to expose such functionality through libraries, such as a <code>String.trimIndent()</code> method:</p>
<pre><code>String s = `a long multi-
            line string`.trimIndent();</code></pre>
<p>But then people will immediately complain that (a) the overly-long string is what gets put in the constant pool, and (b) the trimming is done at run time, possibly redundantly, unless the result is pulled into a static field. But, because <code>trimIndent()</code> is a pure function of its receiver, we can mark <code>trimIndent()</code> as foldable and do the trimming at compile time, and put the trimmed string in the constant pool (and do constant propagation on it.) Supporting compile-time foldable libraries can reduce the pressure to have the language do things that really should be the province of libraries.</p>
<h4 id="de-capturing-of-lambdas">De-capturing of lambdas</h4>
<p>Lambdas that capture effectively final local variables from the enclosing lexical context are compiled differently, and are more expensive to evaluate, than non-capturing lambdas. Constant propagation can move constant information into lambdas, potentially moving them from capturing to non-capturing. For example, given:</p>
<pre><code>String prefix = &quot;#&gt; &quot;;
strings.stream().map(s -&gt; p + s).forEach(System.out::println);</code></pre>
<p>The lambda <code>s -&gt; p + s</code> is a capturing lambda, capturing the local variable <code>p</code> from the enclosing context. However, if the compiler is able to identify it as a compile-time constant (which it now can), it can constant-propagate the constant into the lambda, which reduces the number of captured arguments (in this case, from 1 to 0.)</p>
<h2 id="summary">Summary</h2>
<p>The <code>ConstantRef</code> API is useful for intrinsics, but it is also useful for a number of other activities, such as bytecode APIs (which must deal in unresolved constants), bootstraps that spin bytecode (such as <code>LambdaMetafactory</code>, and offline code analyzers (annotation processors, <code>jlink</code> plugins.) So while our initial target was intrinsics for <code>ldc</code> and <code>invokedynamic</code>, the resulting API is far more generally useful for many low-level activities.</p>
<p>Similarly, the language support for constant propagation and folding were initially motiviated by the needs of intrinsics, but the mechanism is far more general and has the potential to pay generous dividends in the form of generating better code.</p>
<div class="footer" id="footer">
<img src="http://openjdk.java.net/images/openjdk-small.png">
<br>© 2021 Oracle Corporation and/or its affiliates
<br><a href="http://openjdk.java.net/legal/tou/">Terms of Use</a>
· License: <a href="http://openjdk.java.net/legal/gplv2+ce.html">GPLv2</a>
· <a href="http://www.oracle.com/us/legal/privacy/">Privacy</a>
· <a href="http://www.oracle.com/us/legal/third-party-trademarks/third-party-trademarks-078568.html">Trademarks</a>
</div>
</body>
</html>
